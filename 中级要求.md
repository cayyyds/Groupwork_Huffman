# Project2 中级功能 File_Code() 文档  
（基于方案 A：从 code.txt 加载编码表）

---

## 1. 中级功能目标

中级功能 `File_Code()` 的主要职责是：

- 从 `f1.txt` 读取原文内容  
- 从 `code.txt` 读取 Huffman 编码表  
- 将原文逐字符替换为对应的 Huffman bit 串  
- 按 bit 写入输出文件 `f1_result.huf`  
- 使用结构体 `Buffer` 管理 bit 缓冲  
- 统计压缩前 / 压缩后的 bit 数，计算压缩比  

此阶段仅完成压缩，不负责解码。

---

## 2. bit 输出结构体（Buffer）

```cpp
struct Buffer {
    char ch;           // 缓冲字节（最多存 8 位）
    unsigned int bits; // 当前写入的有效 bit 数（0~8）
};
```

### 结构体含义：

- **ch**：暂存的 1 字节，bit 写入前不断左移并追加新的 bit
- **bits**：当前累计的 bit 数

### 工作机制：

- 每次 `Write(bit)` 写入 1 bit
- 当 `bits == 8` → 调用 `fputc(ch, outfp)` 写入 1 字节
- 文件结束后如不足 8 位，需要调用 `WriteToOutfp()` 补齐 0 并写入

---

## 3. 中级功能 File_Code() 的完整流程

```
File_Code()
│
├── Step 1：从 code.txt 加载编码表 loadCodeTable()
│
├── Step 2：打开 f1.txt（原始文件）
│
├── Step 3：打开 f1_result.huf（二进制写，输出文件）
│
├── Step 4：初始化 buf（buf.ch = 0, buf.bits = 0）
│
├── Step 5：逐字符读取 f1.txt
│       └── 从 codeMap 查找该字符对应 Huffman 编码串
│       └── 对编码串逐 bit 调用 Write(bit)
│
├── Step 6：WriteToOutfp() 写出末尾不足 8 bit 的字节
│
└── Step 7：输出压缩比（compressed_bits / original_bits）
```

---

## 4. 新增函数 loadCodeTable()

用于从 code.txt 文件读取编码表。

```cpp
map<char, string> loadCodeTable(const string& filename);
```

### 功能说明：

1. 打开 code.txt
2. 按行读取 **字符 + 频度 + 编码**
3. 建立映射关系：
   - **键**：原文字符（char）
   - **值**：Huffman 编码（二进制字符串）

### 示例 code.txt：
```
A 7 0
T 5 10
C 2 110
S 4 111
```

### 解析后得到：
```cpp
{
  {'A', "0"},
  {'T', "10"},
  {'C', "110"},
  {'S', "111"}
}
```

---

## 5. 输出文件结构（.huf）

在中级部分，`.huf` 文件 **仅包含 bit 压缩流**：

- 原文 Huffman 编码后的 bit 序列
- 按 8 位打包写入字节
- 尾部不足 8 位补 0

### 示意图：

```
原文：      CAST
编码：      110 0 111 10
连接：      110011110
分组：      11001111 0(补0000000)
写入字节：  0xCF     0x00
```




